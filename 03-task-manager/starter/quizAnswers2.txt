
    In this lesson, you created a middleware function called asyncWrapper. Why?
    - It handles custom errors apart from the errors that are built into the express module. It uses try and catch to test out 
    that the correct option is input and if not it will print an error. The asyncwrapper is a function so that you don't have to code
    in the try and catch for every task. It is built into the async function

    Suppose that you want to make sure that both a status code and an error message 
    are sent back to the user when they request the URL for a task that does not exist.
     Assume that youâ€™ve created a CustomAPIError class and an error handler that references that class. Complete the code:

const getTask = asyncWrapper(async (req, res, next) => {  
  const { id: taskID } = req.params;  
  const task = await Task.findOne({ _id: taskID });  
  if (!task) {  
    return next(createCustomError(`No task with id: ${taskID}`, 404))
  }  
  res.status(200).json({ task });  
});  

As you will see in the lessons that follow, you do not have to always create the asyncWrapper middleware, 
because you can instead use an NPM package called express-async-errors that provides the same capability.